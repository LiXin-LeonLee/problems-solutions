# 动态规划



## 简单



### 最大子序和

> 给定一个整数数组 `nums` ，找到一个具有最大和的连续子数组（子数组最少包含一个数），返回其最大和。
>
> **示例:**
>
> **输入:** `[-2,1,-3,4,-1,2,1,-5,4]`,
> **输出:** `6`
> **解释:** 连续子数组 `[4,-1,2,1]` 的和最大，为 `6`。
>
> **进阶:**
>
> 如果你已经实现复杂度为 O(*n*) 的解法，尝试使用更为精妙的分治法求解。

* **方案 1**
* 优化解结构：
  * 最大连续子序列和只可能是以位置 `0～n-1` 中某个位置 `j` 结尾的子序列的最大和 `S[j]`
  * `nums` 最大连续子序列和 `T(n) = max{ S[j], 0 <= j <= n-1 }`
* 递归定义：
  * 某个位置 `j` 结尾的子序列的最大和 `S[j]` 为：`( S[j-1] > 0 ? S[j-1] : 0 ) + nums[j]`

```javascript
let maxSubArray = function(nums) {
    let s = [nums[0]];
    const len = nums.length;
    for (let i=1; i<len; i++) {
        s[i] = (s[i-1] > 0 ? s[i-1] : 0) + nums[i];
    }
    return Math.max.apply(null, s);
};

// 时间复杂度：O(n)；空间复杂度：O(n)
```



### 爬楼梯

> 你正在爬楼梯。需要 *n* 步你才能到达顶部。
>
> 每次你可以爬 1 或 2 个台阶。你有多少种不同的方式可以爬到楼顶呢？
>
> **注意：**给定 *n* 将是一个正整数。
>
> **示例 1：**
>
> ```
> 输入： 2
> 输出： 2
> 说明： 有两种方法可以爬到顶端。
>
> 1.  1 步 + 1 步
> 2.  2 步
> ```
>
>  **示例 2：**
>
> ```
> 输入： 3
> 输出： 3
> 说明： 有三种方法可以爬到顶端。
>
> 1.  1 步 + 1 步 + 1 步
> 2.  1 步 + 2 步
> 3.  2 步 + 1 步
> ```

* **方案 1**
* 分析子结构：
  * 走完 n 步，则最后一次有可能是 1 步或者 2 步，记 s(n)  n 步到达楼顶的方案数
    * 如果是 1 步，则方式有 s(n-1) 种
    * 如果是 2 步，则方式有 s(n-2) 种
* 递归定义：
  * s(n) = s(n-1) + s(n-2)

```javascript
let climbStairs = function(n) {
    let s = [1, 1];
    for (let i=2; i<=n; i++) {
        s[i] = s[i-1] + s[i-2];
    }
    return s[n];
};
```



### 买卖股票的最佳时机

> 假设你有一个数组，其中第 `i` 个元素是一支给定股票第 `i` 天的价格。
>
> 如果您只能完成最多一笔交易（即买入和卖出一股股票），则设计一个算法来找到最大的利润。
>
> **示例 1:**
>
> ```
> 输入: [7, 1, 5, 3, 6, 4]
> 输出: 5
>
> 最大利润 = 6-1 = 5（不是 7-1 = 6, 因为卖出价格需要大于买入价格）
> ```
>
>  **示例 2:**
>
> ```
> 输入: [7, 6, 4, 3, 1]
> 输出: 0
>
> 在这种情况下, 没有交易完成, 即最大利润为 0。
> ```

* **方案 1**

* 分析：

  * 将利润抽象为差值，差值最大时卖出的天数 `i` 一定存在于 `1 ~ n-1` 的某个位置
  * 差值最大 `maxProfit = max{ profit[i], 1 <= i <= n-1 }`


  * 某天 `i` 卖出的最大差值（当前价格减去目前最小的价格）`profit[i] = prices[i] - minPrice`

```javascript
let maxProfit = function(prices) {
    let _maxProfit = 0;
    let minPrice = prices[0];
    const len = prices.length;
    for (let i=1; i<len; i++) {
        if(minPrice > prices[i]) {
            minPrice = prices[i];
        } else {
            _maxProfit = Math.max(_maxProfit, prices[i] - minPrice);
        }
    }
    return _maxProfit;
};

// 时间复杂度：O(n)；空间复杂度：O(1)
```

* **方案 2**
* 将价格数组后一个元素减去前一个元素，得到一个股票价格差值数组，转换成最大子序和求解



### 打家劫舍

> 你是一个专业的强盗，计划抢劫沿街的房屋。每间房都藏有一定的现金，阻止你抢劫他们的唯一的制约因素就是相邻的房屋有保安系统连接，**如果两间相邻的房屋在同一晚上被闯入**，**它会自动联系警方**。
>
> 给定一个代表每个房屋的金额的非负整数列表 `nums`，确定你可以在**没有提醒警方的情况下**抢劫的最高金额。

* **方案 1**
* 分析最优子结构：
  * `1~n` 间店铺，最高金额 `S(n)` 的两种可能结果：
    * 第 `n` 间抢，最高金额就等于第 `n` 间金额加上前 `n-2` 间的最高金额
    * 第 `n` 间不抢，最高金额就等于前 `n-1` 间的最高金额
* 递归定义：
  * 最高金额：`S(n) = max{ S(n-1), S(n-1) + nums[n-1] }`

```javascript
var rob = function (nums) {
    let amount = [0, nums[0]];
    const len = nums.length;
    for (let i = 2; i <= len; i++) {
        amount[i] = Math.max(amount[i - 1], amount[i - 2] + nums[i - 1]);
    }
    return amount[len];
};

// 时间复杂度：O(n)；空间复杂度：O(n)
```

